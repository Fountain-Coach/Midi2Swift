import Foundation

struct CLI {
    var inPath: String = "spec/matrix.json"
    var outPath: String = "swift/Midi2Swift/Sources"
    static func parse() -> CLI {
        var cli = CLI()
        var it = CommandLine.arguments.dropFirst().makeIterator()
        while let arg = it.next() {
            switch arg {
            case "--in":
                if let v = it.next() { cli.inPath = v }
            case "--out":
                if let v = it.next() { cli.outPath = v }
            case "--help", "-h":
                print("SwiftGen â€” generate Swift sources from spec/matrix.json")
                print("Usage: SwiftGen --in spec/matrix.json --out swift/Midi2Swift/Sources")
                exit(0)
            default:
                fputs("Unknown argument: \(arg)\n", stderr)
                exit(2)
            }
        }
        return cli
    }
}

let cli = CLI.parse()

// Load matrix JSON as dictionary for flexible access
let url = URL(fileURLWithPath: cli.inPath)
guard FileManager.default.fileExists(atPath: url.path) else {
    fputs("SwiftGen error: matrix not found at \(cli.inPath)\n", stderr)
    exit(2)
}
let data = try Data(contentsOf: url)
guard let matrix = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
    fputs("SwiftGen error: matrix is not a JSON object\n", stderr)
    exit(2)
}

// Extract meta.pdf_sha256 for provenance
let meta = matrix["meta"] as? [String: Any]
let pdfSHA = meta?["pdf_sha256"] as? [String: String] ?? [:]
let generatedAt = meta?["generated_at"] as? String ?? ""

// Extract catalog families if present
var families: [String] = []
if let catalog = matrix["catalog"] as? [String: Any],
   let ump = catalog["ump"] as? [String: Any],
   let fams = ump["families"] as? [String] {
    families = fams
}

// Helper: write a file
func write(_ relPath: String, contents: String) throws {
    let outURL = URL(fileURLWithPath: cli.outPath).appendingPathComponent(relPath)
    try FileManager.default.createDirectory(at: outURL.deletingLastPathComponent(), withIntermediateDirectories: true)
    try contents.data(using: .utf8)!.write(to: outURL, options: .atomic)
}

// Generate Core/Generated/Version.swift
let coreVersion = """/// Generated by SwiftGen on \(generatedAt)
/// PDF SHA-256 provenance:
/// \(pdfSHA.sorted { $0.key < $1.key }.map { " - \($0): \($1)" }.joined(separator: "\n/// "))
public enum Midi2SwiftBuild {
    public static let generatedAt: String = "\(generatedAt)"
    public static let pdfSHA256: [String:String] = [
        \(pdfSHA.sorted { $0.key < $1.key }.map { "\"\($0)\": \"\($1)\"" }.joined(separator: ",\n        "))
    ]
}
"""
try write("Core/Generated/Version.swift", contents: coreVersion)

// Generate UMP/Generated/Catalog.swift
let umpCatalog = """/// UMP catalog families (seeded; items populated in later PRs)
public enum UMPCatalogFamily: String, CaseIterable {
\(families.map { "    case \($0) = \"\($0)\"" }.joined(separator: "\n"))
}
"""
try write("UMP/Generated/Catalog.swift", contents: umpCatalog)

print("SwiftGen: generated Core/Generated/Version.swift and UMP/Generated/Catalog.swift")


// MARK: - Message code generation from matrix["messages"]
struct FieldDef {
    let name: String
    let bitOffset: Int
    let bitWidth: Int
    let isReserved: Bool
}
struct MessageDef {
    let family: String
    let name: String
    let containerBits: Int
    let fields: [FieldDef]
}

func parseMessages(from matrix: [String: Any]) -> [MessageDef] {
    guard let arr = matrix["messages"] as? [Any] else { return [] }
    var out: [MessageDef] = []
    for item in arr {
        guard let m = item as? [String: Any] else { continue }
        let family = m["family"] as? String ?? "Unknown"
        let name = m["name"] as? String ?? "Unnamed"
        let containerBits = m["containerBits"] as? Int ?? 32
        var fields: [FieldDef] = []
        if let f = m["fields"] as? [[String: Any]] {
            for fd in f {
                guard let fn = fd["name"] as? String,
                      let bo = fd["bitOffset"] as? Int,
                      let bw = fd["bitWidth"] as? Int else { continue }
                let res = (fd["reserved"] as? Bool) ?? false
                fields.append(.init(name: fn, bitOffset: bo, bitWidth: bw, isReserved: res))
            }
        }
        out.append(.init(family: family, name: name, containerBits: containerBits, fields: fields))
    }
    return out
}

func genBitHelpers() -> String {
    return """        @inlinable public func beShift(_ N: Int, _ o: Int, _ w: Int) -> Int { return N - o - w }
    @inlinable public func beMask(_ w: Int) -> UInt64 { return (w == 64) ? ~UInt64(0) : ((UInt64(1) << w) &- 1) }
    """
}

func genMessageType(_ m: MessageDef) -> (path: String, contents: String) {
    let typeName = m.name.replacingOccurrences(of: ".", with: "_")
    let N = m.containerBits
    let containerType = (N == 32 ? "UMP32" : (N == 64 ? "UMP64" : "UMP128"))
    let containerRaw = (N == 32 ? "UInt32" : (N == 64 ? "UInt64" : "/* UInt128 */"))
    var fieldsDecl = ""
    var encodeBody = ""
    var decodeBody = ""
    for f in m.fields {
        fieldsDecl += "    public var \(f.name): UInt64\n"
        let shift = "\(N) - \(f.bitOffset) - \(f.bitWidth)"
        // Encode (big-endian view)
        let mask = "beMask(\(f.bitWidth))"
        let shifted = "( (\(f.name) & \(mask)) << \(shift) )"
        if N == 32:
            encodeBody += "        raw = (raw & ~\(containerRaw)(\(mask) << \(shift))) | \(containerRaw)(\(shifted))\n"
            decodeBody += "        let \(f.name) = UInt64((raw >> \(shift)) & \(containerRaw)(\(mask)))\n"
        elif N == 64:
            encodeBody += "        raw = (raw & ~\(containerRaw)(\(mask) << \(shift))) | \(containerRaw)(\(shifted))\n"
            decodeBody += "        let \(f.name) = UInt64((raw >> \(shift)) & \(containerRaw)(\(mask)))\n"
        else:
            # For UMP128, emit placeholder comment (no stubs or compile errors)
            pass
    }
    if N == 32:
        encodeHeader = "        var raw: UInt32 = 0\n"
        decodeHeader = "        let raw = v.raw\n"
    elif N == 64:
        encodeHeader = "        var raw: UInt64 = 0\n"
        decodeHeader = "        let raw = v.raw\n"
    else:
        encodeHeader = "        // 128-bit encode not implemented in this PR\n        return nil\n"
        decodeHeader = "        // 128-bit decode not implemented in this PR\n        return nil\n"

    let code = """        // Generated message: \(m.name)
    public struct \(typeName) {
    \(fieldsDecl)
        public init(\(m.fields.map { "\($0.name): UInt64" }.joined(separator: ", "))) {
    \(m.fields.map { "        self.\($0.name) = \($0.name)" }.joined(separator: "\n"))
        }
        @inlinable public func encode() -> \(containerType)? {
    \(encodeHeader)\
    \(encodeBody)\
            return \(containerType)(raw)
        }
        @inlinable public static func decode(_ v: \(containerType)) -> \(typeName)? {
    \(decodeHeader)\
    \(decodeBody)\
            return \(typeName)(\(m.fields.map { "\($0.name): \($0.name)" }.joined(separator: ", ")))
        }
    }
    """
    let rel = "UMP/Generated/Messages/\(m.family)/\(typeName).swift"
    return (rel, code)
}

func genRegistry(_ messages: [MessageDef]) -> String {
    let names = messages.map { "\($0.name)" }.sorted()
    var cases = names.map { "        case "\($0)"" }.joined(separator: "\n")
    var encodeSwitch = ""
    var decodeSwitch = ""
    for m in messages {
        let typeName = m.name.replacingOccurrences(of: ".", with: "_")
        let container = (m.containerBits == 32 ? "UMP32" : (m.containerBits == 64 ? "UMP64" : "UMP128"))
        let argList = m.fields.map { "fields["\($0.name)"] ?? 0" }.joined(separator: ", ")
        encodeSwitch += "        case "\(m.name)": return \(typeName)(\(argList)).encode().map { .\(m.containerBits == 32 ? "w32" : (m.containerBits == 64 ? "w64" : "w128"))($0) }\n"
        decodeSwitch += "        case "\(m.name)":\n"
        if m.containerBits == 32:
            decodeSwitch += "            guard case let .w32(v) = container, let x = \(typeName).decode(v) else { return nil }\n"
        elif m.containerBits == 64:
            decodeSwitch += "            guard case let .w64(v) = container, let x = \(typeName).decode(v) else { return nil }\n"
        else:
            decodeSwitch += "            return nil\n"
        decodeSwitch += "            return [\(m.fields.map { "\"\($0.name)\": x.\($0.name)" }.joined(separator: ", "))]\n"
    }
    let reg = """        public enum UMPContainer { case w32(UMP32), w64(UMP64), w128(UMP128) }
    public enum MessageRegistry {
        public static func encode(name: String, fields: [String: UInt64]) -> UMPContainer? {
            switch name {
    \(encodeSwitch)\
            default: return nil
            }
        }
        public static func decode(name: String, container: UMPContainer) -> [String: UInt64]? {
            switch name {
    \(decodeSwitch)\
            default: return nil
            }
        }
    }
    """
    return reg
}

// Parse messages and generate files
let messages = parseMessages(from: matrix)
try write("Core/Generated/BitEndian.swift", contents: genBitHelpers())
for m in messages {
    let g = genMessageType(m)
    try write(g.path, contents: g.contents)
}
try write("UMP/Generated/Registry.swift", contents: genRegistry(messages))

print("SwiftGen: generated \(messages.count) message types and registry.")
